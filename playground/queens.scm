(define (filter predicat sequence)
  (if (null? sequence)
    '()
    (if (predicat (car sequence))
      (cons (car sequence) (filter predicat (cdr sequence)))
      (filter predicat (cdr sequence)))))
(define (accumulate op initial sequence)
  (if (null? sequence)
    initial
    (op (car sequence)
        (accumulate op initial (cdr sequence)))))
(define (enumerate-interval a b)
  (if (> a b)
    '()
    (append (list a) (enumerate-interval (+ a 1) b))))
(define (flatmap proc sequence)
  (accumulate append '() (map proc sequence)))
(define empty-board '())
(define (make-position row col)
  (cons row col))
(define (position-row position)
  (car position))
(define (position-col position)
  (cdr position))
(define (adjoin-position row col positions)
  (append positions (list (make-position row col))))

(define (safe? col positions)
  (let ((kth-queen (list-ref positions  (- col 1)))
        (other-queens (filter (lambda (q)
                                (not (= col (position-col q))))
                              positions)))
    (define (attacks? q1 q2)
      (or (= (position-row q1) (position-row q2))
          (= (abs (- (position-row q2) (position-row q1)))
             (abs (- (position-col q1) (position-col q2))))))
    (define (iter queen other-queens)
      (or (null? other-queens)
          (and (not (attacks? queen (car other-queens)))
               (iter queen (cdr other-queens)))))
    (iter kth-queen other-queens)))

(define (queens board-size)
  (define empty-board '())
  (define (queen-cols k)
    (if (= k 0)
      (list empty-board)
      (filter
        (lambda (positions) (safe? k positions))
        (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position
                     new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))

(queens 4)
